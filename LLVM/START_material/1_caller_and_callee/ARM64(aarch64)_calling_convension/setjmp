(https://stackoverflow.com/questions/4097034/arm-cortex-a8-whats-the-difference-between-vfp-and-neon)
ARM Cortex-A8: Whats the difference between VFP and NEON ????

There are quite some difference between the two. Neon is a SIMD (Single Instruction Multiple Data) accelerator processor as part of the ARM core. It means that during the execution of one instruction the same operation will occur on up to 16 data sets in parallel. Since there is parallelism inside the Neon, you can get more MIPS or FLOPS out of Neon than you can a standard SISD processor running at the same clock rate.

The biggest benefit of Neon is if you want to execute operation with vectors, i.e. video encoding/decoding. Also it can perform single precision floating point(float) operations in parallel.

VFP is a classic floating point hardware accelerator. It is not a parallel architecture like Neon. Basically it performs one operation on one set of inputs and returns one output. It's purpose is to speed up floating point calculations. It supports single and double precision floating point.

You have 3 possibilities to use Neon:

use intrinsics functions #include "arm_neon.h"
inline the assembly code
let the gcc to do the optimizations for you by providing -mfpu=neon as argument (gcc 4.5 is good on this)

=================================================================================================================
What is difference between normal function and setjmp.
-normal function is execute once where setjmp is execute twice.

#include<stdio.h> 
#include<setjmp.h> 
jmp_buf buf; 
void func() 
{ 
    printf("Welcome\n"); 
  
    // Jump to the point setup by setjmp 
    longjmp(buf, 0); 
  
    printf("Geek2\n"); 
} 
  
int main() 
{ int r;
int result;
    // Setup jump position using buf and return 0 
    if (r=setjmp(buf)) 
    {
        printf("r2=%d\n",r);
        printf("Hello\n");
    }
    else
    { 
        printf("r1=%d\n",r);
        printf("World\n");
        func();
    }  
     return 0; 
}
===========================================================================================


use setjmp and longjmp man pages
explain assembly 
===================================================================================================================

https://stackoverflow.com/questions/22168992/why-are-conditionally-executed-instructions-not-present-in-later-arm-instruction

In assembly part of setjmp.s 

General claim is modern systems have better branch predictors and compilers are much more advanced so their cost on instruction encoding space is not justified.

This is from (https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf)

The A64 instruction set does not include the concept of predicated or conditional execution. Benchmarking shows that modern branch predictors work well enough that predicated execution of instructions does not offer sufficient benefit to justify its significant use of opcode space, and its implementation cost in advanced implementations.

And it continues

A very small set of “conditional data processing” instructions are provided. These instructions are unconditionally executed but use the condition flags as an extra input to the instruction. This set has been shown to be beneficial in situations where conditional branches predict poorly, or are otherwise inefficient.

Another paper titled Trading Conditional Execution for More Registers on ARM Processors claims:
(https://ieeexplore.ieee.org/document/5703498)

... conditional execution takes up precious instruction space as conditions are encoded into a 4-bit condition code selector on every 32-bit ARM instruction. Besides, only small percentages of instructions are actually conditionalized in modern embedded applications, and conditional execution might not even lead to performance improvement on modern embedded processors.

===================================================================================================================





