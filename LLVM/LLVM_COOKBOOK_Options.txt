LLVM options:-
=============

1. How to check perticular optimizations or multiple optimizations
// Below options are for new passmanger 
$ ./opt testfile.ll -passes=instcombine -S					// Single opt
$ ./opt testfile.ll -passes=deadargelim,instcombine -S      // two opt

// Below options are for old passmanger 
$ opt –S –instcombine testfile.ll –o output1.ll

-----------------------------------------------------------------------------------------------------
NOTE:- Cross-complation

- By cross-compiling we mean building a binary on one platform (for example, x86) that will be run on
another platform (for example, ARM). The machine on which we build the binary is called the host,
and the machine on which the generated binary will run is called the target. The compiler that builds
code for the same platform on which it is running (the host and target platforms are the same) is called
a native assembler, whereas the compiler that builds code for a target platform different from the
host platform is called a cross-compiler.

- Cross-complation details are given in LLVM cookbook. (Chapter-1) LLVM design and use

- The LLVM bit code file format (also known as bytecode) is actually two things: a bitstream container format and an encoding of LLVM IR
into the container format.
-----------------------------------------------------------------------------------------------------

2. How to convert IR to bitcode(LLVM assembler => llvm-as)
$ ./llvm-as test.ll –o test.bc

3. To view Bitcode use below command
$ hexdump -C testfile.bc

-----------------------------------------------------------------------------------------------------
NOTE:- BitCodeFormat

- To encode LLVM IR into bitcode, the concept of blocks and records is used. Blocks represent regions
of bitstream, for example—a function body, symbol table, and so on. Each block has an ID specific to
its content (for example, function bodies in LLVM IR are represented by ID 12).

- To get a detailed understanding of the LLVM the bitstream file format, refer to
http://llvm.org/docs/BitCodeFormat.html#abstract

- By specifying -march=architecture flag in the preceding command, you can specify the target
architecture for which the assembly needs to be generated. Using the -mcpu=cpu flag setting, you
can specify a CPU within the architecture to generate code.
-----------------------------------------------------------------------------------------------------

4. Converting LLVM bitcode to target machine assembly
$ ./llc testfile.bc -o testfile.s
		OR
$ ./clang -S testfile.bc -o testfile.s # using the clang front end
		
5. Converting LLVM bitcode back to LLVM assembly (LLVM disassembler => llvm-dis)
$ ./llvm-dis testfile.bc -o testfile.ll

-----------------------------------------------------------------------------------------------------
NOTE:- opt tool

- When the –analyze option is passed to opt, it performs various analyses of the input source and
prints results usually on the standard output or standard error. Also, the output can be redirected to a
file when it is meant to be fed to another program.

- When the –analyze option is not passed to opt, it runs the transformation passes meant to optimize the
input file. All tranfomation source availble in llvm/test/Transforms folder
-----------------------------------------------------------------------------------------------------

6. Linking LLVM bitcode
-> you will link previously generated .bc files to get one single bitcode file containing
all the needed references.
-> Note that this is not the traditional linker that links various object files to generate 
a binary. The llvm-link tool links bitcode files only.
$ llvm-link test1.bc test2.bc –o output.bc

7. Executing LLVM bitcode (lli tool)
-> It takes the input in LLVM bitcode format and executes it using a just-in-time compiler, 
if there is one available for the architecture, or an interpreter.)
-> If lli is making use of a just-in-time compiler, then it effectively takes all the code generator options
as that of llc.

$ ./lli check.bc

8. Dump ast of code
$ ./clang -cc1 test.c -ast-dump

9. How to generate output on standard output 
$ ./clang -emit-llvm check.c -S  -o -   // "-o -" => It generates the output on standard output

-----------------------------------------------------------------------------------------------------
NOTE:- 
-> Golang compiler details are given in this book(Page 53). Page https://github.com/go-llvm/llgo









Last Page - 54